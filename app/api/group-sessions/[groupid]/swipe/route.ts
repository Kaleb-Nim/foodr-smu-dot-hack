import { NextRequest, NextResponse } from 'next/server';
import { PrismaClient, FoodRating } from '@prisma/client';
import { z } from 'zod';

// Initialize a single instance of Prisma Client
const prisma = new PrismaClient();

// 1. Define a validation schema for the incoming request body using Zod.
// This matches the frontend's data structure and values.
const swipeRequestSchema = z.object({
  userId: z.string().uuid({ message: "Invalid user ID format." }),
  dishId: z.string().uuid({ message: "Invalid dish ID format." }),
  preference: z.enum(['like', 'dislike', 'super-like']),
});

// 2. Helper function to map frontend preferences to the Prisma Enum.
// This keeps the mapping logic clean and reusable.
const mapPreferenceToEnum = (preference: string): FoodRating => {
  switch (preference) {
    case 'super-like':
      return FoodRating.SUPER_LIKE;
    case 'dislike':
      return FoodRating.DISLIKE;
    default:
      return FoodRating.LIKE;
  }
};

export async function POST(req: NextRequest, { params }: { params: { groupid: string } }) {
  const sessionId = params.groupid;

  try {
    // 3. Validate Request Body
    // Safely parse the request JSON. If it fails, Zod throws an error.
    const body = await req.json();
    const { userId, dishId, preference } = swipeRequestSchema.parse(body);

    // 4. Authorization
    // Find the group and include its members to check for authorization.
    const group = await prisma.group.findUnique({
      where: { id: sessionId },
      include: {
        members: {
          select: { id: true }, // Only select the member IDs for efficiency
        },
      },
    });

    if (!group) {
      return NextResponse.json({ error: "Group session not found" }, { status: 404 });
    }

    const isMember = group.members.some(member => member.id === userId);
    if (!isMember) {
      return NextResponse.json({ error: "User is not a member of this group" }, { status: 403 });
    }

    // 5. Map preference to the Prisma Enum
    const ratingEnum = mapPreferenceToEnum(preference);

    // 6. Database Upsert Operation
    // Prisma's `upsert` is perfect here. It finds a record based on the unique
    // constraint `person_id_fk_food_id_fk` and either updates it or creates it.
    const savedRating = await prisma.ratings.upsert({
      where: {
        // This compound unique index name is auto-generated by Prisma from `@@unique`.
        person_id_fk_food_id_fk: {
          person_id_fk: userId,
          food_id_fk: dishId,
        },
      },
      update: {
        // If the record exists, only update the rating.
        rating: ratingEnum,
      },
      create: {
        // If it doesn't exist, create a new record with all required fields.
        person_id_fk: userId,
        food_id_fk: dishId,
        rating: ratingEnum,
      },
    });

    // 7. Success Response
    return NextResponse.json(
      { message: "Swipe recorded successfully", data: savedRating },
      { status: 200 }
    );

  } catch (error) {
    // Handle validation errors from Zod
    if (error instanceof z.ZodError) {
      return NextResponse.json(
        { error: "Invalid request body", details: error.errors },
        { status: 400 }
      );
    }
    
    // Handle other potential errors (e.g., Prisma client errors)
    console.error("Error recording swipe:", error);
    return NextResponse.json({ error: "An unexpected error occurred." }, { status: 500 });
  }
}